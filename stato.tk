# version  : 2.02 - November 2020
# author   : Thierry Le Gall
# contact  : facila@gmx.fr
# web site : https://github.com/facila/stato

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

sub stato_tk {
$y_win = $y_win + 2;

use Tk;
use Tk::NoteBook;
use Tk::BrowseEntry;

$main = MainWindow->new   ;
$main->title($title)      ;
$main->geometry($geometry);
$main->setPalette($bg)    ;
$main->resizable(0,0)     ;

# book : init pages
$book = $main->NoteBook->pack(-fill=>'both',-expand=>1);
#$book->configure(-dynamicgeometry=>1);

$page{help}  = $book->add('help' ,-label=>$text_help ,-raisecmd=>sub{$page='help' });
$page{state} = $book->add('state',-label=>$text_state,-raisecmd=>sub{$page='state'; &execute if ! $s1 ; $s1 = 1 });
$page{mib}   = $book->add('mib'  ,-label=>$text_mib  ,-raisecmd=>sub{$page='mib'  ; &execute if ! $m1 ; $m1 = 1 });
$page{exec}  = $book->add('exec' ,-label=>$text_exec ,-raisecmd=>\&execute);
$page{quit}  = $book->add('quit' ,-label=>$text_quit ,-raisecmd=>sub{exit});

# page help
$help = $page{help}->Text()->pack(-fill=>'both',-expand=>1);
$help->insert('end',$file_help);
$help->configure(-state=>'disabled',-width=>$x_win,-height=>$y_win);

# page state
$frame{state} =  $page{state}->Frame->pack(-fill=>'x');
$state_host   = $frame{state}->Label      (-text=>" $text_host : $host_all    ")->pack(-side=>'left');
$check_format = $frame{state}->Checkbutton(-text=>$text_format                 )->pack(-side=>'left');
$check_format->configure(-variable=>\$format,-command=>\&sort);

$heading = $page{state}->Text    (-state=>'disable',-height=>1,-bd=>0)->pack(-fill=>'x');
$state   = $page{state}->Scrolled('Text',-scrollbars=>'osoe')->pack(-fill=>'both',-expand=>1);
$state->configure(-wrap=>'none',-state=>'disable',-width=>$x_win,-height=>$y_win);

# page mib
$frame{mib} = $page{mib}->Frame->pack(-fill=>'x');

$list = 'system' if ! $list;
$mib_host  = $frame{mib}->Label      (-text=>" $text_host : $host_all    ")->pack(-side=>'left');
$mib_label = $frame{mib}->Label      (-text=>$text_mib_list               )->pack(-side=>'left');
$mib_list  = $frame{mib}->BrowseEntry(-variable=>\$list,-choices=>\@list  )->pack(-side=>'left');
$mib_list->configure(-state=>'readonly');
#$mib_list->configure(-autolistwidth=>1,-autolimitheight=>1,-state=>'readonly');

$mib = $page{mib}->Scrolled('Text',-scrollbars=>'osoe')->pack(-fill=>'both',-expand=>1);
$mib->configure(-wrap=>'none',-state=>'disable',-width=>$x_win,-height=>$y_win);

# application des polices et des couleurs
foreach('book','state','mib','help','state_host','check_format','heading','mib_host','mib_label','mib_list') {
   $$_->configure(-bg=>$bg,-fg=>$fg,-font=>$font) }

$book        ->configure(-inactivebackground=>$bg_2,-backpagecolor=>$bg);
$check_format->configure(-selectcolor       =>$fg);
$mib_list    ->configure(-disabledbackground=>$bg,-disabledforeground=>$fg);

# initialisation etat des interfaces
$book->raise('state');

MainLoop }

sub execute {
    $book->raise($page);
    return if $page eq 'help';

    $snmp = 0;
    &clear($$page);
    &test;
    &$page(0) if $snmp;
    &display($$page) }

# fonctions affichage
sub clear {
    $affi = $_[0];
    %tag_fg = %tag_bg = ();
    $affi->configure(-state=>'normal' );
    $affi->delete('1.0','end'         );
    $affi->insert('1.0',"\n $msg_wait");
    $main->configure(-cursor=>'watch' ); $main->idletasks;
    $book->configure(-cursor=>'watch' ); $book->idletasks;
    $affi->configure(-cursor=>'watch' ); $affi->idletasks }

sub display {
    my $affi = $_[0];

    chomp ($text);
    $affi->delete('1.0','end');
    $affi->insert('1.0',$text);

    foreach $ligne (keys %tag_fg) {
       $affi->tagAdd      ($ligne,"$ligne.0","$ligne.0 lineend") ;
       $affi->tagConfigure($ligne,-foreground=>$tag_fg{$ligne},-background=>$tag_bg{$ligne}) }

    $affi->configure(-state =>'disable');
    $affi->configure(-cursor=>'xterm'  );
    $book->configure(-cursor=>'top_left_arrow');
    $main->configure(-cursor=>'top_left_arrow') }

sub heading_tk {
    # affichage de la ligne d'entete
    $heading->configure(-state=>'normal' );
    $heading->delete   ('1.0','end'      );
    $heading->insert   ('end',$text      );
    $heading->configure(-state=>'disable');

    # calcul des positions des champs pour affecter les tags pour le tri
    $x = $y = $lg_total = 0;
    $a[0] = 1;
    foreach (@lg) {
       $y ++;
       $b[$x] = $a[$x] + $_;
       $a[$y] = $b[$x] + 1 ;
       $x ++;
       $lg_total = $lg_total + $_ + 1 }
    $espace = $x_win + 2 - $lg_total; # nombre d'espace Ã  ajouter aux lignes

    $x = 0;
    foreach (@pos) {
       $y = length($text_field[$x]);
       if ($_ eq '-') { $b[$x] = $a[$x] + $y }
       else           { $a[$x] = $b[$x] - $y }
       $x ++ }

    $x = 0;
    foreach (@field) {
       $heading->tagAdd($_,"1.$a[$x]","1.$b[$x]");
       &tag_sort_init ($_);
       $x ++ } }

sub color {
    # gestion de la couleur des lignes par interface (tag)
    $ligne++;
    $groupe++ if $id ne $id_old;
    $id_old = $id;

    # couleur du text en fonction de @color
    my($c,$v,$v2);
    $tag_fg = '';
    foreach (@color) { ($c,$v,$v2) = split /\s+/; if ($$c =~ /$v/) { $tag_fg = $v2 } }
    if (! $tag_fg) { $tag_fg = $color_interface_up }

    # couleur de fond , 1 interface sur 2 , $bg ou $bg_2
    $tag_bg = $bg; if (! ($groupe % 2)) { $tag_bg = $bg_2 }
    foreach (@reverse_video) { ($c,$v) = split /\s+/; if ($$c =~ /$v/) { $tag_bg = $tag_fg; $tag_fg = $bg } }

    $tag_fg{$ligne} = $tag_fg;
    $tag_bg{$ligne} = $tag_bg }

# initialisation $sort_old
$sort_old = $sort;

sub sort {
    if ($_[1]) {
       $sort = $_[1];
       if ($sort eq $sort_old) { $sense = $sense * -1 }
       else                    { $sense = 1 } }
    $sort_old = $sort;
    foreach(@field) { $heading->tagConfigure($_,-background=>$bg,-foreground=>$fg) }
    $heading->tagConfigure($sort,-background=>$fg,-foreground=>$bg);

    &clear($state);
    &result;
    &display($state) }

sub tag_sort_init {
    my $tag = $_[0];
    if ($tag eq $sort) { $heading->tagConfigure($tag,-background=>$fg,-foreground=>$bg) }
    $heading->tagBind($tag,"<Button-1>",[\&sort,$tag]);
    $heading->tagBind($tag,"<Enter>"   ,[\&tag_sort_enter,$tag]);
    $heading->tagBind($tag,"<Leave>"   ,[\&tag_sort_leave,$tag]) }

sub tag_sort_enter {
    my $tag = $_[1];
    $heading->tagConfigure($tag,-background=>$fg,-foreground=>$bg);
    $heading->configure(-cursor=>'hand2') }

sub tag_sort_leave {
    my $tag = $_[1];
    if ($tag ne $sort) { $heading->tagConfigure($tag,-background=>$bg,-foreground=>$fg) }
    $heading->configure(-cursor=>'xterm') }

1 ;
